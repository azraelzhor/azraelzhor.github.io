[{"authors":["admin"],"categories":null,"content":"Who am I in this manipulated world?\nA lost sheep seeking for piousness.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://azraelzhor.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Who am I in this manipulated world?\nA lost sheep seeking for piousness.","tags":null,"title":"Thang Le","type":"authors"},{"authors":null,"categories":null,"content":"Last year, I had a chance to be involved in an Advanced Computer Vision class held by a non-profit organization. During the class, object detection is one of the fields that I found myself interested in the most. This motivated me to write a series of blogs in order to understand better some famous approaches that has been applied in the field. Though, the idea has been postponed until recently :v. The first part of this series is about Faster RCN, one of the state-of-the-art method used for object detection. In this blog post, I will walk you through the detail of Faster RCNN. Hopefully, at the end of this blog, you would figure out the way Faster RCNN works.\nOutline   Object detection  Faster RCNN   VGG Shared Network  Region Proposal Network  Region-based CNN    Loss Function   Regression Loss  Classification Loss    Training   Augment data  Create anchor generator    Detection  A little bit of object detection In object detection, we received an image with bounding boxes indicating a various type of objects. There are many approaches these days.\n\nFaster RCNN architecture Faster RCNN is the last detection model in the RCNN trilogy (RCNN - Fast RCNN - Faster RCNN), which relies on proposed regions to detect objects. Though, unlike its predecessors which use selective search to find out the best regions, Faster RCNN makes use of neural network and \u0026ldquo;learn\u0026rdquo; to propose regions directly. These proposed regions then is fed into another neural network to be refined once again.\nFirst, let take a look at the overall architecture of Faster RCNN. It comprises of $2$ modules\n The region proposal module takes feature map from a feature network and proposes regions The Fast RCNN detector module takes those regions to predict the classes that the object belongs to.  The feature network, which is VGG in the context of this blog, is shared between both model.\nTo easily keep track of the story, let\u0026rsquo;s follow a specific example in which we are given an image of shape $300\\times400\\times3$.\nFeature Shared Network [TODO]Pretrained models\nWe use VGG as a feature network. The VGG receives an input image and produce a feature map with reduced sizes. The size of the feature map is determined by the net structure. For example, in case we use VGG, the feature map\u0026rsquo;s shape is $18 \\times 25 \\times 512$.\nRegion Proposal Network (RPN) The goal of RPN is to propose regions that highly contain object. In order to do that, RPN does\n generate a predefined number of fixed-size anchors predict the objectness of each of these anchors refine their coordinates  Predefined anchors For each pixel spatial location on the VGG feature map, we generate a predefined number of fixed size anchors. The shape of these anchor boxes are determined by a combination of predefined scales and edge ratios. In our example, if we use $3$ scales $64$, $128$, $256$ and $3$ edge ratios $1:1$, $1:2$, $2:1$, there will be $3*3=9$ type of anchors at each pixel location and a total of $18 * 25 * 9 = 4050$ anchors to be generated as a result. It is important to note that even though anchor boxes are created based on the feature map\u0026rsquo;s spatial location, they reference to the original input image, in which anchor boxes generated from the same feature map pixel location are centered at the same point on the original input, as illustrated in this figure below. RPN architecture The RPN is then designed to predict objectness of each anchor (classification) and its coordinates (regression). It consists of $3$ layers: one convolutional layer with $512$ filters of size $3 \\times 3$ followed by two sibling $1 \\times 1$ convolutional layers. These two sibling layers - one with $K$ filters and the other with $4K$ filters - allow for classification and regression, respectively.\nIn our example, after passing the VGG feature map through RPN, it produces a classification output with shape of $18 \\times 25 \\times K$ and a regression output with shape of $18 \\times 25 \\times 4K$, where $K$ denotes the number of generated anchors at each feature map location.\ndef rpn(base_layers, num_anchors): x = Conv2D(512, (3, 3), padding='same', activation='relu', kernel_initializer='normal', name='rpn_conv1')(base_layers) x_class = Conv2D(num_anchors, (1, 1), activation='sigmoid', kernel_initializer='uniform', name='rpn_out_class')(x) x_regr = Conv2D(num_anchors * 4, (1, 1), activation='linear', kernel_initializer='zero', name='rpn_out_regress')(x) return [x_class, x_regr, base_layers]  Create labeled data for training RPN Now, we need labeled data to train the RPN.\nLabel for classification For training classification task, each anchor box is labeled as\n positive - containing object negative - background ignored - being ignored when training  based on the overlap with its nearest ground-truth bounding box.\nWe use IoU to measure these overlaps. Let $p$ denotes the IoU between current anchor box and its nearest ground-truth bounding box. The rule is detailed as follows\n If $p \u0026gt; \\text{max_rpn}$, label it positive If $p \u0026lt; \\text{min_rpn}$, label it negative If $\\text{min_rpn} \u0026lt; p \u0026lt; \\text{max_rpn}$, ignore it when training  # overlaps for RPN cfg.rpn_min_overlap = 0.3 cfg.rpn_max_overlap = 0.7  Label for regression The anchor box refinement is modeled as a regression problem, in which we predict the delta $(\\color{red}{t_x, t_y, t_w, t_h})$ for each anchor box. This delta denotes the change needed to refine our predefined anchor boxes, as illustrated in this figure below\nFormally, we have\n $$\\begin{align} \\color{blue}{x} \u0026 = x_a + \\color{red}{t_x}*w_a \\\\ \\color{blue}{y} \u0026 = y_a + \\color{red}{t_y}*h_a \\\\ \\color{blue}{w} \u0026 = w_a * e^{\\color{red}{t_w}} \\\\ \\color{blue}{h} \u0026 = h_a * e^{\\color{red}{t_h}} \\end{align} $$  or\n $$\\begin{align} \\color{red}{t_x} \u0026 = (\\color{blue}{x} - x_a) / w_a \\\\ \\color{red}{t_y} \u0026 = (\\color{blue}{y} - y_a) / h_a \\\\ \\color{red}{t_w} \u0026 = log(\\color{blue}{w}/w_a) \\\\ \\color{red}{t_h} \u0026 = log(\\color{blue}{h}/h_a) \\end{align} $$  where $(x_a, y_a, w_a, h_a)$ denotes the anchor box\u0026rsquo;s coordinates and $(\\color{blue}{x, y, w, h})$ denotes the refined box\u0026rsquo;s coordinates.\nTo create data for anchor regression training, we calculate the \u0026ldquo;ground-truth\u0026rdquo; delta $(\\color{red}{t_x^*, t_y^*, t_w^*, t_h^*})$ based on each anchor box\u0026rsquo;s coordinates $(x_a, y_a, w_a, h_a)$ and its nearest ground-truth bounding box\u0026rsquo;s coordinates $(\\color{blue}{x^*, y^*, w^*, h^*})$.\n $$\\begin{align} \\color{red}{t_x^*} \u0026 = (\\color{blue}{x^*} - x_a) / w_a \\\\ \\color{red}{t_y^*} \u0026 = (\\color{blue}{y^*} - y_a) / h_a \\\\ \\color{red}{t_w^*} \u0026 = log(\\color{blue}{w^*}/w_a) \\\\ \\color{red}{t_h^*} \u0026 = log(\\color{blue}{h^*}/h_a) \\end{align} $$  Among those generated anchor boxes, the positive anchors are probably outnumbered by the negative ones. Thus, to avoid imbalanced classification, we only use some anchor boxes for training. Specifically, only $256$ anchor boxes is chosen for training the RPN.\nFor example, with $4050$ anchor boxes generated, assume that we have $4000$ anchor boxes labeled as \u0026ldquo;positive\u0026rdquo;, $50$ anchor boxes labeled as \u0026ldquo;negative\u0026rdquo;\nRPN losses 1. Regression Loss The smooth L1 loss is used for regression training. Its formulation is as below\n$$smooth_{L1}(x) = \\begin{cases} 0.5x^2 \u0026amp; \\mbox{if} ; \\lvert x \\rvert \u0026lt; 1, \\\n\\lvert x \\rvert - 0.5 \u0026amp; \\mbox{otherwise}. \\end{cases} $$\nwhere $x$ denotes the difference between prediction and ground truth $t - \\color{blue}{t^*}$.\nThe reason smooth L1 loss is preferred to L1 and L2 loss is because it can handle the problem of these two losses. Being quadratic for small values ($\\lvert x \\rvert \u0026lt; 1$) and linear for large values ($\\lvert x \\rvert \\geq 1$), smooth L1 loss is now less sensitive to outliers than L2 loss and also does not suffer from the problem of L1 loss, which is not differentiable around zero.\n# regression loss for rpn def rpn_loss_regr(cfg): def rpn_loss_regr_fixed_num(y_true, y_pred): x = y_true[:, :, :, 4 * cfg.num_anchors:] - y_pred x_abs = K.abs(x) x_bool = K.cast(K.less_equal(x_abs, 1.0), tf.float32) return cfg.lambda_rpn_regr * K.sum( y_true[:, :, :, :4 * cfg.num_anchors] * (x_bool * (0.5 * x * x) + (1 - x_bool) * (x_abs - 0.5))) / K.sum(cfg.epsilon + y_true[:, :, :, :4 * cfg.num_anchors]) return rpn_loss_regr_fixed_num  2. Classification Loss def rpn_loss_cls(cfg): def rpn_loss_cls_fixed_num(y_true, y_pred): return cfg.lambda_rpn_class * K.sum(y_true[:, :, :, :cfg.num_anchors] * K.binary_crossentropy(y_pred[:, :, :, :], y_true[:, :, :, cfg.num_anchors:])) / K.sum(cfg.epsilon + y_true[:, :, :, :cfg.num_anchors]) return rpn_loss_cls_fixed_num  Use RPN to propose regions RPN prediction After training, we use RPN to predict the bounding box coordinates at each feature map location.\nIn our example, there is $4050$ anchor boxes in total. Assume that the RPN predict $3000$ positive bounding boxes - meaning that they are containing object.\nNon-max suppression It is very likely that there are many bounding boxes, among those are predicted by RPN, referring to the same object. This leads to redundant proposals, which can be eliminated by an algorithm known as non max suppression. The idea of non max suppression is to filter out all but the box with highest confidence score for each highly-overlapped bounding box cluster, making sure that a particular object is identified only once.\nThe algorithm can be summarized as follows:\n Given a list of proposals along with their confidence score, and a predefined overlap threshold  Initialize a list $L$ to contain bounding boxes. Sort the list, denoted by $S$, by confidence score in descending order Iterate through $S$, at each iteration  Compute the overlap between the current bounding box and the remain bounding boxes in $S$ Suppress all bounding boxes that have the computed overlap above the predefined threshold hold from $S$ Discard the current box from $S$, then move it to $L$   Return $L$    Region-based Convolutional Neural Network Now we have feature map patches as regions ready for the next phase. Now one notable problem arises here is that those proposed regions are not in the same shape, which makes it difficult for neural network training. This is where we need RoI pooling layer to help construct fixed-size feature maps from those arbitrary-size regions.\nRoI Pooling To understand RoI pooling, let begin with a 2D example.\nA 2D example No matter what the shape of the input slice is, a $2 \\times 2$ RoI pooling layer always transform the input to the output of size $2 \\times 2$ by\n Split the input into a $2 \\times 2$ matrix of roughly equal regions Do max pooling on each region  like this figure below (given input of shape $4 \\times 4$ or $5 \\times 5$).\nRoI used in Faster RCNN Detection Network Those fixed-size feature maps from RoI pooling are then flattened and subsequently fed into a fully connected network for final detection. The net consists of $2$ fully connected layers of $4096$ neurons, followed by other $2$ sibling fully connected layers - one has $N$ neurons for classifying proposals and the other has $4*(N - 1)$ neurons for bounding box regression, where $N$ denotes the number of classes, including the background. Note that when a bounding box is classified as background, regression is unneeded. Hence, it makes sense that we only need $4*(N - 1)$ neurons for regression in total.\nIn our example, each $7\\times7\\times512$ feature map is fed to the detection net to produce the classification output has size of $4$, and the regression output has size of $12$.\nLabeled data for FCNN Label for classification Similar to the RPN, we make use of IoU metric to label data. Let $p$ denotes the overlap between a refined anchor box produced by RPN and its nearest ground-truth anchor box. For each anchor box we label as follows\n if $p \u0026lt; \\text{min_cls}$, ignore it when training. if $\\text{min_cls} \\leq p \u0026lt; \\text{max_cls}$, label it as background. if $p \\geq \\text{max_cls}$, label it as the class to which its nearest ground-truth box belongs.  cfg.classifier_min_overlap = 0.1 cfg.classifier_max_overlap = 0.5  Label for bounding box regression For regression, we also calculate the \u0026ldquo;ground-truth\u0026rdquo; deltas $(\\color{red}{t_x^*, t_y^*, t_w^*, t_h^*})$ in the same fashion as those in RPN, but now based on each refined anchor box\u0026rsquo;s coordinates from the RPN $(x_r, y_r, w_r, h_r)$ and its nearest ground-truth bounding box\u0026rsquo;s coordinates $(\\color{blue}{x^*, y^*, w^*, h^*})$.\n -- RCNN losses 1. Regression Loss # regresssion loss for detection network def class_loss_regr(num_classes, cfg): def class_loss_regr_fixed_num(y_true, y_pred): x = y_true[:, :, 4*num_classes:] - y_pred x_abs = K.abs(x) x_bool = K.cast(K.less_equal(x_abs, 1.0), 'float32') return cfg.lambda_cls_regr * K.sum(y_true[:, :, :4*num_classes] * (x_bool * (0.5 * x * x) + (1 - x_bool) * (x_abs - 0.5))) / K.sum(cfg.epsilon + y_true[:, :, :4*num_classes]) return class_loss_regr_fixed_num  2. Classification Loss def class_loss_cls(cfg): def class_loss_cls_fixed_num(y_true, y_pred): return cfg.lambda_cls_class * K.mean(categorical_crossentropy(y_true[0, :, :], y_pred[0, :, :])) return class_loss_cls_fixed_num   ## Training  ## Detection -- References\n Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks ( arxiv)  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"b5e738e0afbd9d7feca0f89b9bd56e24","permalink":"https://azraelzhor.github.io/post/faster-rcnn/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/post/faster-rcnn/","section":"post","summary":"Last year, I had a chance to be involved in an Advanced Computer Vision class held by a non-profit organization. During the class, object detection is one of the fields that I found myself interested in the most. This motivated me to write a series of blogs in order to understand better some famous approaches that has been applied in the field. Though, the idea has been postponed until recently :v.","tags":null,"title":"Dive into Faster RCNN","type":"post"},{"authors":null,"categories":null,"content":"If you have been involving in machine learning for a while, you should have known about residual networks, which are proved to be powerful for image classification. Yet, apart from classification, they can be made invertible by some simple tricks to be used in other machine learning tasks as well. This family of residual networks called Invertible Residual Networks has been proposed recently by J Behrmann, 2018. In this blog post, I will walk you through the invention of invertible residual networks.\nTable of Contents   The motivation   Density estimation  Normalizing Flows   A change of variables  A normalizing flows    The awesome residual block    Making the nets invertible   Fixed-point theorem  Enforcing Lipschitz constraint  How to yield the inverse output    Computing the log likelihood   Log determinant  Hutchinsons estimator    Implementations  \nThe motivation Classification only tells difference between data points. This is clearly not fulfilling for greedy human beings. We want a better understanding of data or, to be more specific, the data distribution itself. This underlying distribution of data is literally what the task of density estimation tries to estimate.\n\nDensity estimation Density estimation can be achieved through maximum likelihood estimation, in which we try to maximize the expected log-likehood\n $$ \\mathbf{E}_{x \\sim p_{data}(x)}{p(x; \\theta)} $$  $$ \\mathbf{E}_{x \\sim p_k(x) }{p(x; \\theta)} $$\nwhere $p_{data}(x)$ denotes the empirical distribution of observed data and $p(x; \\theta)$ denotes our assumed parametric distribution (simply known as model distribution).\nYet, when data is complex and high dimensional, a problem arises. It is hard to construct a parametric distribution which is not only expressive enough to capture the complexity of data but also tractable for maximum likelihood estimation. This hurdle can be overcome with the help of normalizing flows, in which we rely on them to construct our more complex model distribution from a simple latent prior. As a parametric bridge between these two distributions, normalizing flows allow for tractable data likelihood computation, which makes maximum likelihood estimation now possible.\n\nNormalizing Flows Normalizing flows were first introduced to solve the problem of density estimation. Though, it later became popular when introduced to deal with variational inference by [1]. The idea of normalizing flows is very simple that it transforms one distribution to another arbitrarily complex distribution, through a sequence of invertible mapping functions.\n\nA change of variables But, let\u0026rsquo;s first take a look at a change of variables rule, which forms the basis for normalizing flows.\nFigure 1. A change of variablesGiven a random variable $x$ with its density function known as $p(x)$, if we map this variable using an invertible mapping $f$, so that $z = f(x)$ and $x = f^{-1}(z) ; \\forall x, z,$ then $z$ is still a random variable. Its normalized density function is then defined as follows\n$$ p(z) = p(x) \\left\\lvert \\det\\frac{\\partial f^{-1}}{\\partial z} \\right\\rvert = p(x) {\\left\\lvert \\det\\frac{\\partial f}{\\partial x} \\right\\rvert}^{-1}, \\tag{1} $$\nwhere the first equality is due to preservation of total probability of in both domain; and the second equality follows from the inverse function theorem.\nTaking logarithm of each side, we can rewrite $(1)$ as\n$$\\ln p(z) = \\ln p(x) - \\ln \\left\\lvert \\det J_f(x) \\right\\rvert$$\nwhere $J_f$ denotes the Jacobian matrix of function $f$ evaluated at point $x$.\n\nA normalzing flow Figure 2. A normalizing flowWe can now form a normalizing flow by chaining together a finite sequence of these variable changes just described above. As an example, let us consider a flow in figure 2, in which we have $$z \\equiv z_K = f_K \\circ \u0026hellip; \\circ f_2 \\circ f_1 (x) \\equiv F(x)$$\nBy consecutively applying variables change formula $(2)$, we get\n $$\\begin{align} \\ln p(z) = \\ln p(z_K) \u0026 = \\ln p(z_{K-1}) - \\ln \\left\\lvert \\det J_{f_K}(z_{K-1})\\right\\rvert \\\\ \u0026 = \\ln p(z_{K-2}) - \\sum_{k=K-1}^{K}\\ln \\left\\lvert \\det J_{f_k}(z_{k-1})\\right\\rvert \\\\ \u0026 = \\;... \\\\ \u0026 = \\ln p(x) - \\sum_{k=1}^{K} \\ln \\left\\lvert \\det J_{f_k}(z_{k-1})\\right\\rvert \\\\ \\end{align}$$  Continuing the derivation we get\n $$\\begin{align} \\ln p(z) \u0026 = \\ln p(x) - \\ln \\left\\lvert \\prod_{k=1}^{K} \\det J_{f_k}(z_{k-1})\\right\\rvert \\\\ \u0026 = \\ln p(x) - \\ln \\left\\lvert \\det \\prod_{k=1}^{K} J_{f_k}(z_{k-1})\\right\\rvert \\ (\\because \\det(AB) = \\det(A)\\det(B)) \\\\ \u0026 = \\ln p(x) - \\ln \\left\\lvert \\det J_F(x)\\right\\rvert \\ (\\textrm{because of derivative chain rule})\\\\ \\end{align}$$  It is easy to realize that the last equation is literally a variables change formula with transformation $F$. This does make sense because a normalizing flow can also be viewed as a change of variables but with a much more complex invertible transformation. Here, $F$ is clearly invertible as it is a composition of an arbitrary number of invertible functions. By designing an appropriate $F$, we can obtain an arbitrarily complex normalized density function at the completion of a normalizing flow. Hence, normalizing flows can be intuitively interpreted as a systematic way to distort the input density function, making it more complex (like in variational inference setting) or simpler (like in density estimation setting). However, in order for normalizing flows to be useful in practice, we need to have two conditions satisfied\n The determinant of their Jacobian matrices $J_{f_k}$ need to be **easy to compute**, in order to obtain a tractable likelihood. Those transformation functions $f_k$ obviously need to be invertible.  In fact, many approaches have been proposed to construct those easy-to-use transformation functions lately. Inspired by normalizing flows, the authors of the paper has also managed to exploit residual networks as transformation functions used for normalizing flows. Thus, before diving into the details, let take a look back at the architecture of residual networks.\n\nThe awesome residual block Residual network is composed of a sequence of residual blocks, with each block can be simplified as this figure below\nFigure 3. A residual block-- Figure 3. A residual blockAs we can see, each residual block consists of a residual part denoted by $g$ and an identity part. From mathematical viewpoint, each block can be clearly counted as a function which takes input $x$ and produces $z$ as output. Formally, we have $$ z = f(x) = g(x) + x \\tag{1} $$\nBack to our main story, it is obvious that the goal is to make use of residual network as a transformation function for normalizing flows. Since residual network can be interpreted as a composition function of multiple residual blocks, making each individual block invertible is a sufficient condition for the invertibility of the whole net.\n\nMaking the nets invertible In the inverse phase, each block takes $z$ as input and produces $x$ as output. Thus, in order for a block to be invertible, we need to enforce the existence and uniqueness of output $x$ for each input $z$.\nFrom $(1)$, we have $$x = z - g(x)$$\nLet define $h(x) = z - g(x)$ to be a function of $x$, where z acts as a constant. The requirement can now be formulated as follows: The equation $x = h(x)$ must have only one root or, to put it in a formal way, $h(x)$ has a unique fixed point.\n Fixed point: Let X be a metric space and let T: X → X be a mapping in X. A fixed point of T is a point in X such that T(x) = x.\n Fortunately, this requirement can be obtained according to the famous Banach fixed-point theorem.\nFixed point theorem The Banach fixed point theorem, also called contraction mapping theorem, states that every contraction mapping in a complete metric space admits a unique fixed point.\n Contraction mapping: Let $(M, d)$ be a complete metric space. A function $T$: $M$ → $M$ is a contraction mapping if there exists a real number $0 \\leq k \u0026lt; 1$ such that:\n$$\\quad d(T(x), T(y)) \\leq k d(x, y) , \\quad \\quad \\forall x, y \\in M$$\nThe smallest $k$ for which the above inequality holds is called the Lipschitz constant of $f$, denoted by $Lip(T)$\n Banach theorem: Let $(M, d)$ be a complete metric space and $T$: $M$ → $M$ be a contraction mapping. Then T has a unique fixed point $x \\in M$. Furthermore, if $y \\in M$ is arbitrary chosen, then the iterates ${ {x_n}}_{n=0}^\\infty$, given by\n $$\\begin{align} \u0026 x_0 = y \\\\ \u0026 x_n = T(x_{n-1}), n \\geq 1, \\end{align}$$  have the property that $\\lim_{n\\to\\infty} x_n = x$ as illustrated in the figure below.\nFigure 1. Banach fixed point theorem**Banach fixed point theorem**  Let $(M, d)$ be a complete metric space and let $T$: $M$ \u0026rightarrow; $M$ be a contraction mapping. Then T has a unique fixed point $x \\in M$. Furthermore, if $y \\in M$ is arbitrary chosen, then the iterates $\\{ {x_n}\\}_{n=0}^\\infty$, given by $$ x_0 = y$$  $$ x_n = T(x_{n-1}), n \\geq 1, $$  have the property that $\\lim_{n\\to\\infty} x_n = x$. -- [TODO] - Talk a little bit about Banach theorem\nEnforcing Lipschitz constraint Based on the Banach theorem above, our enforcing condition then becomes\n$$Lip(h) \u0026lt; 1 ;\\textrm{or}; Lip(g) \u0026lt; 1$$\nHence $g$ can be implemented as a composition of contractive linear or nonlinear mappings like the figure below.\nFigure 3. Contractive residual mapping For nonlinear mappings, ReLU, ELU and tanh are the possible choices for contraction constraint. For linear mappings, implemented as convolutional layers $W_i$, they can be made contractive by satisfying the condition $$\\lVert W_i \\rVert_2 \u0026lt; 1 \\quad \\forall W_i$$ where $\\lVert a \\rVert_2$ denotes the spectral norm of matrix a.   Spectral norm of a matrix: The largest singular value of a matrix.\n The spectral norm of non-square matrix $W_i$ can be directly estimated using the power iteration algorithm (by Gouk et el. 2018), which yields an underestimate $\\tilde \\sigma_i \\leq \\lVert W_i \\rVert_2$. The algorithm can be summarized as follows:\n $$\\begin{align} \u0026 \\textrm{Initialize} \\; x_0 \\\\ x_k \u0026 = W_i^T W_i x_{k - 1}, \\; \\forall k, 1 \\leq k \\leq n \\\\ \\tilde \\sigma_i \u0026 = \\frac{\\lVert W_i x_n\\rVert_2}{\\lVert x_n \\rVert_2} \\\\ \\end{align}$$  We then normalize the parameter $W_i$ by\n$$ \\tilde{W_i} = \\begin{cases} \\frac{cW_i}{\\tilde \\sigma_i}, \u0026amp; \\mbox{if} ; \\frac{c}{\\tilde \\sigma_i} \u0026lt; 1 \\\nW_i, \u0026amp;\\mbox{else} \\end{cases}$$ where $c$ is the hyperparameter ($c \u0026lt; 1$).\n\nHow to yield the inverse output Though the constraint above guarantees invertibility of the residual network, it does not provide any analytical form for the inverse. Fortunately, inverse output of each residual block can be yielded through a simple fixed-point iteration, as described below\n Initialize value $x = x_0$ For each iteration $i$, $x_{i+1} = h(x_i) = z - g(x_i)$  Computing the likelihood So far, we have managed to construct invertible residual networks. We can now make use of them as a transformation for density estimation.\nBut there is still one problem need to be dealt with. In order for the likelihood to be tractable, we need to compute the determinant of the Jacobian matrix of the residual network $F$ or, instead, the determinant of the Jacobian matrix of each residual block $f$. $$\\ln p(x) = \\ln p(z) + \\ln \\left\\lvert \\det J_F(x)\\right\\rvert = \\ln p(z) + \\sum_{k=1}^{K} \\ln \\left\\lvert \\det J_{f_k}(z_{k-1})\\right\\rvert$$ The computation of the determinant of full Jacobian matrix requires $O(d^3)$ time, which makes it prohibitive for high-dimensional data like image. Fortunately, we can approximate the term in a certain way.\nThe log determinant term For each residual block $f$, we have\n $$\\begin{align} \\ln \\left\\lvert \\det J_f(x)\\right\\rvert \u0026 = \\ln (\\det J_f(x)) \\textrm{( $\\det J_f$ is always positive)} \\\\ \u0026 = tr(\\ln J_f(x)) \\textrm{($\\ln \\det A = tr(\\ln(A))$)} \\\\ \u0026 = tr(ln\\frac{\\partial f}{\\partial x}) \\\\ \u0026 = tr(ln\\frac{\\partial (x + g(x))}{\\partial x})\\\\ \u0026 = tr(ln\\ (I + J_g(x))) \\textrm{($I$ denotes identity matrix)} \\\\ \u0026 = tr(\\sum_{k=1}^\\infty(-1)^{k + 1}\\frac{J_g^k}{k}) \\textrm{(power series expression of matrix logarithm)} \\\\ \u0026 = \\sum_{k=1}^\\infty(-1)^{k + 1}\\frac{tr(J_g^k)}{k} \\textrm{($tr(A + B) = tr(A) + tr(B)$)} \\\\ \\end{align}$$   Matrix logarithm and its power series expression: A logarithm of matrix $M$ is any matrix $X$ such that $e^X = M$. It can be expressed as a power series $$ln(M) = \\sum_{k=1}^\\infty(-1)^{k + 1}\\frac{(M - I)^k}{k}$$ whenever the series converges.\n Now the log-determinant term has been rewritten as an infinite sum of traces of matrix powers, which makes it easier to approximate. Even though, there is still a bunch of drawbacks if we want to approximate the term:\n Computing $tr(J_g)$ costs $O(d^2)$ Computing matrix powers $J_g^k$ requires knowledge of full Jacobian The series is infinite  Hutchinson trace estimator Evaluating the trace of matrix powers $J_g^k$ is expensive due to full knowledge of Jacobian matrix and also matrix-matrix multiplications, hence comes the Hutchinson method for trace approximation.\nHutchinson trace estimator is a Monte Carlo approach to approximate the trace of matrix powers, for example $J_g^k$ in our case, without fully evaluating them. Specifically, a random vector $v$ is introduced to estimate the trace $$tr(A) = \\mathrm{E}_{v \\sim p(v)}v^{T}Av $$\nwith the constraint that $v$ is drawn from a fixed distribution $p(v)$, satisfying $\\mathrm{E}[v] = 0$ and $\\mathrm{Var}[v] = I$. Hence it is obvious that the Gaussian $N(0, I)$ is a good choice for $p(v)$. Applying the trace estimator, we have\n$$ tr(J_g^k) = \\mathrm{E}_{v \\sim N(0, I)} v^T J_g^k v $$\nThe matrix power computation can be circumvented by evaluating $v^T J_g^k v$ in a recursive fashion\n $$\\begin{align} w_0 \u0026 = v \\\\ w_k \u0026 = J_g w_{k - 1}, \\forall k \\geq 1 \\\\ v^T J_g^k v \u0026 = v^T w_k \\\\ \\end{align}$$  which requires now only matrix-vector multiplication.\nFurthermore, the term $w_k$ can be evaluated roughly as the same cost as evaluating $g$ using reverse-mode automatic differentiation, alleviating the heavy computation of evaluating $J_g$ explicitly.\nNow, the only problem remains is the computation of infinite series, which can be addressed by truncating the series at a finite index $n$\n$$\\ln |\\det J_f(x)| \\approx \\sum_{k=1}^{n}(-1)^{k + 1}\\frac{tr(J_g^k)}{k}$$\nImplementation Original implementation by the paper\u0026rsquo;s author: ( link)\nA TensorFlow implementation by me: ( link)\nReferences\n  Variational Inference with Normalizing Flows  Invertible Residual Networks  Normalizing Flows: An Introduction and Review of Current Methods  High-Dimensional Probability Estimation with Deep Density Models  Hutchinson\u0026rsquo;s Trick  Spectral Normalization Explained  Regularisation of Neural Networks by Enforcing Lipschitz Continuity  Large-scale Log-determinant Computation through Stochastic Chebyshev Expansions  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"b06c8416d3613a34de7f2d674b8607f1","permalink":"https://azraelzhor.github.io/post/invertible-residual-networks/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/post/invertible-residual-networks/","section":"post","summary":"If you have been involving in machine learning for a while, you should have known about residual networks, which are proved to be powerful for image classification. Yet, apart from classification, they can be made invertible by some simple tricks to be used in other machine learning tasks as well. This family of residual networks called Invertible Residual Networks has been proposed recently by J Behrmann, 2018. In this blog post, I will walk you through the invention of invertible residual networks.","tags":null,"title":"Invertible Residual Networks for Generative Modeling","type":"post"}]